<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flight Training Game</title>
    <style>
        /* --- CSS ‡πÄ‡∏î‡∏¥‡∏°‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î --- */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Arial', sans-serif; background: linear-gradient(135deg, #1e3c72, #2a5298); color: white; overflow: hidden; }
        .game-container { display: flex; flex-direction: column; height: 100vh; position: relative; }
        .header { display: flex; justify-content: space-between; align-items: center; padding: 10px 20px; background: rgba(0,0,0,0.3); height: 60px; }
        .score-board { display: flex; gap: 30px; }
        .score-item { text-align: center; }
        .score-label { font-size: 12px; opacity: 0.8; }
        .score-value { font-size: 24px; font-weight: bold; color: #00ff88; }
        .crash-value { font-size: 24px; font-weight: bold; color: #ff4444; }
        .timer { text-align: center; }
        .timer-label { font-size: 12px; opacity: 0.8; }
        .timer-value { font-size: 28px; font-weight: bold; color: #ff6b6b; }
        .target-display { width: 24px; height: 24px; border-radius: 50%; border: 2px solid rgba(255,255,255,0.7); margin-left: 10px; }
        .target-item { display: flex; align-items: center; }
        canvas { background: #000; border: 2px solid #333; display: block; }
        .settings-panel { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.9); border-radius: 20px; padding: 30px; min-width: 400px; border: 2px solid rgba(255,255,255,0.1); z-index: 100; }
        .settings-title { text-align: center; font-size: 24px; margin-bottom: 30px; color: #00ff88; }
        .setting-group { margin-bottom: 25px; }
        .setting-label { display: block; margin-bottom: 10px; font-size: 16px; }
        .setting-control { width: 100%; padding: 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.3); background: rgba(255,255,255,0.1); color: white; font-size: 16px; }
        .setting-control option { background: #2a2a2a; color: white; }
        .btn { padding: 12px 24px; border: none; border-radius: 8px; font-size: 16px; cursor: pointer; transition: all 0.3s; }
        .btn-primary { background: #00ff88; color: black; }
        .btn-secondary { background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.3); }
        .buttons { display: flex; gap: 15px; justify-content: center; margin-top: 30px; }
        .hidden { display: none !important; }
        .result-summary { background: rgba(255,255,255,0.05); border-radius: 10px; padding: 25px; margin-bottom: 30px; border: 1px solid rgba(255,255,255,0.1); }
        .summary-grid { display: grid; grid-template-columns: auto 1fr; gap: 15px 20px; font-size: 20px; align-items: center; }
        .summary-grid span:first-child { font-weight: bold; color: rgba(255,255,255,0.7); text-align: right; }
        .summary-grid span:nth-child(2) { font-weight: bold; font-size: 26px; color: #00ff88; text-align: left; }
        .summary-grid span:nth-child(4) { font-weight: bold; font-size: 26px; color: #ff4444; text-align: left; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        /* SECURITY OVERLAY STYLE */
        #security-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; color: #00ff88; z-index: 99999; display: flex; flex-direction: column; justify-content: center; align-items: center; font-family: monospace; font-size: 20px; }
    </style>
</head>
<body>
    <div id="security-overlay">
        <div id="security-msg">üîí Authenticating with Silp Pilot Database...</div>
    </div>

    <div class="game-container">
        <div class="header">
            <div class="score-board">
                <div class="score-item"><div class="score-label">Points</div><div class="score-value" id="points">0</div></div>
                <div class="score-item"><div class="score-label">Crashes</div><div class="crash-value" id="crashes">0</div></div>
                <div class="score-item target-item">
                    <div class="score-label" style="font-size: 14px;">Target:</div>
                    <div id="target-display" class="target-display" style="background-color: #00ff88;"></div>
                </div>
            </div>
            <div class="timer"><div class="timer-label">Time Remaining</div><div class="timer-value" id="timer">5:00</div></div>
            <button class="btn btn-secondary" onclick="showSettings()">Settings</button>
        </div>
        <canvas id="gameCanvas"></canvas>
    </div>
    
    <div class="settings-panel" id="settingsPanel">
        <h2 class="settings-title">Game Settings</h2>
        <div class="setting-group"><label class="setting-label">Number of Red Balls (1-5):</label><input type="range" class="setting-control" id="redBallCount" min="1" max="5" value="2"><span id="redBallCountValue">2</span> balls</div>
        <div class="setting-group">
            <label class="setting-label">Joystick Sensitivity (1-5):</label>
            <input type="range" class="setting-control" id="joySens" min="1" max="5" value="3">
            <span id="joySensValue">Normal</span>
        </div>
        <div class="setting-group">
            <label class="setting-label">Red Ball Speed:</label>
            <select class="setting-control" id="redBallSpeed">
                <option value="slow">Slow</option>
                <option value="normal" selected>Normal</option>
                <option value="fast">Fast</option>
                <option value="insane">Insane</option>
            </select>
        </div>
        <div class="setting-group"><label class="setting-label">Game Time (minutes):</label><input type="range" class="setting-control" id="gameTime" min="3" max="10" value="5"><span id="gameTimeValue">5</span> minutes</div>
        <div class="buttons">
            <button class="btn btn-primary" onclick="startGame()">Start Game</button>
            <button id="backToMainBtn" class="btn btn-secondary">Back to Main Page</button>
        </div>
    </div>

    <div class="settings-panel hidden" id="gameOverPanel">
        <h2 class="settings-title">Game Finished!</h2>
        <div class="result-summary">
            <div class="summary-grid">
                <span>Points:</span><span id="finalPoints">0</span>
                <span>Crashes:</span><span id="finalCrashes">0</span>
            </div>
        </div>
        <div class="buttons">
            <button class="btn btn-primary" id="playAgainBtn">Play Again</button>
            <button id="backToMainBtn_GO" class="btn btn-secondary">Back to Main Page</button>
        </div>
    </div>

    <script>
        // ==========================================
        // 2. ‡∏™‡πà‡∏ß‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡πå (‡πÅ‡∏ö‡∏ö Ticket Reader - Offline Check)
        // ==========================================
        function checkAccess() {
            const urlParams = new URLSearchParams(window.location.search);
            const authToken = urlParams.get('auth'); // <--- ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏°‡∏≤‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤ auth ‡πÅ‡∏ó‡∏ô token
            const backUrl = urlParams.get('ref');

            // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏õ‡∏∏‡πà‡∏°‡∏¢‡πâ‡∏≠‡∏ô‡∏Å‡∏•‡∏±‡∏ö
            if (backUrl) document.body.dataset.homeUrl = backUrl;

            if (!authToken) {
                // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ auth ‡∏°‡∏≤ ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ô‡∏µ‡πâ (‡∏Ñ‡∏ô‡∏•‡∏∞‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏±‡∏ö‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡πÄ‡∏´‡πá‡∏ô‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Å‡∏µ‡πâ)
                denyAccess("Access Denied: No ticket found.<br>Please launch from Silp Pilot dashboard.");
                return;
            }

            try {
                // ‡∏ñ‡∏≠‡∏î‡∏£‡∏´‡∏±‡∏™‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å‡∏•‡∏¥‡∏á‡∏Å‡πå (Base64 Decode)
                const base64 = authToken.replace(/-/g, '+').replace(/_/g, '/');
                const jsonString = atob(base64); 
                const data = JSON.parse(jsonString);

                // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏ß‡∏•‡∏≤‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏
                if (Date.now() > data.exp) {
                    denyAccess("Ticket Expired.<br>Please return to dashboard and launch again.");
                } else {
                    // ‡∏ú‡πà‡∏≤‡∏ô‡∏â‡∏•‡∏∏‡∏¢!
                    document.getElementById('security-msg').innerHTML = `‚úÖ Pilot Verified: ${data.email}<br>Systems Ready.`;
                    setTimeout(() => {
                        document.getElementById('security-overlay').style.display = 'none';
                    }, 1500);
                }
            } catch (e) {
                console.error(e);
                denyAccess("Invalid Ticket Data.<br>Access Denied.");
            }
        }

        function denyAccess(msg) {
            const overlay = document.getElementById('security-overlay');
            overlay.style.background = "#2a0000";
            overlay.style.color = "#ff4444";
            overlay.innerHTML = `<div style="text-align:center;"><h1>üö´ RESTRICTED AREA</h1><p>${msg}</p><br><a href="#" onclick="window.close()" style="color: white;">Close Window</a></div>`;
        }

        // ==========================================
        // 3. ‡∏™‡πà‡∏ß‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏Å‡∏° (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°‡∏ó‡∏∏‡∏Å‡∏≠‡∏¢‡πà‡∏≤‡∏á)
        // ==========================================
        let canvas, ctx, gameRunning = false;
        let player = { x: 400, y: 300, angle: 0, speed: 0, maxSpeed: 20, acceleration: 0.1, radius: 25 };
        let stars = [], redBalls = [], targets = [], currentTargetColor = 'green';
        let score = { points: 0, crashes: 0 }, crashCooldown = 0, keys = {};
        let playerTurnSpeed = 0.07; // ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡πÄ‡∏Å‡πá‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÑ‡∏ß‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
        let audioCtx = null;

        function initAudio() { try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch (e) { } }
        function playSound(frequency, duration, type = 'sine') { 
            if (!audioCtx) return;
            try { if (audioCtx.state === 'suspended') audioCtx.resume(); const oscillator = audioCtx.createOscillator(), gainNode = audioCtx.createGain(); oscillator.connect(gainNode); gainNode.connect(audioCtx.destination); oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime); oscillator.type = type; gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration); oscillator.start(audioCtx.currentTime); oscillator.stop(audioCtx.currentTime + duration); } catch (e) { } 
        }
        function playCrashSound() { playSound(150, 0.5, 'sawtooth'); setTimeout(() => playSound(100, 0.3, 'square'), 100); if (navigator.vibrate) navigator.vibrate([100, 50, 100]); }
        function playSuccessSound() { playSound(523, 0.2); setTimeout(() => playSound(659, 0.2), 100); setTimeout(() => playSound(784, 0.3), 200); }

        function init() {
            checkAccess(); // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ï‡∏£‡∏ß‡∏à‡∏ö‡∏±‡∏ï‡∏£‡∏ú‡πà‡∏≤‡∏ô‡πÅ‡∏ö‡∏ö‡πÉ‡∏´‡∏°‡πà

            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            const header = document.querySelector('.header');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight - header.offsetHeight;
            player.x = canvas.width / 2;
            player.y = canvas.height / 2;

            createStars(400);
            setupInputs();
            initAudio();

            document.getElementById('redBallCount').oninput = function () { document.getElementById('redBallCountValue').textContent = this.value; };
            document.getElementById('gameTime').oninput = function () { document.getElementById('gameTimeValue').textContent = this.value; };
            const sensLabels = { 1: "Very Low", 2: "Low", 3: "Normal", 4: "High", 5: "Very High" };
            document.getElementById('joySens').oninput = function() {
                document.getElementById('joySensValue').textContent = sensLabels[this.value];
            };
            document.addEventListener('click', () => { if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); });

            ['backToMainBtn', 'backToMainBtn_GO'].forEach(btnId => {
                document.getElementById(btnId).addEventListener('click', function () {
                    const mainPageUrl = document.body.dataset.homeUrl;
                    if(mainPageUrl) window.top.location.href = mainPageUrl;
                    else window.history.back();
                });
            });
            document.getElementById('playAgainBtn').addEventListener('click', function () {
                document.getElementById('gameOverPanel').classList.add('hidden');
                showSettings();
            });
        }

        function createStars(count) {
            stars = [];
            for (let i = 0; i < count; i++) {
                stars.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, radius: Math.random() * 1.2, opacity: 0.5 + Math.random() * 0.5 });
            }
        }

        function setupInputs() {
            window.addEventListener('keydown', e => { switch (e.code) { case 'KeyW': case 'ArrowUp': keys.up = true; break; case 'KeyS': case 'ArrowDown': keys.down = true; break; case 'KeyA': case 'ArrowLeft': keys.left = true; break; case 'KeyD': case 'ArrowRight': keys.right = true; break; case 'Enter': case 'Space': keys.fire = true; break; } });
            window.addEventListener('keyup', e => { switch (e.code) { case 'KeyW': case 'ArrowUp': keys.up = false; break; case 'KeyS': case 'ArrowDown': keys.down = false; break; case 'KeyA': case 'ArrowLeft': keys.left = false; break; case 'KeyD': case 'ArrowRight': keys.right = false; break; case 'Enter': case 'Space': keys.fire = false; break; } });
        }

        // *** ‡∏™‡πà‡∏ß‡∏ô‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç: ‡∏õ‡∏£‡∏±‡∏ö‡∏à‡∏≠‡∏¢‡∏™‡∏ï‡∏¥‡πä‡∏Å‡πÉ‡∏´‡πâ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö Thrustmaster ***
        // *** ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö Analog Stick (‡πÇ‡∏¢‡∏Å‡πÄ‡∏ö‡∏≤/‡πÅ‡∏£‡∏á) ***
        function getCombinedInput() {
            const input = { up: false, down: false, fire: false, turnVal: 0 };
            
            // 1. ‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å Keyboard (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°)
            if (keys.up) input.up = true;
            if (keys.down) input.down = true;
            if (keys.fire) input.fire = true;
            if (keys.left) input.turnVal = -1;
            if (keys.right) input.turnVal = 1;

            // 2. ‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å Joystick
            const gamepad = navigator.getGamepads()[0];
            if (gamepad) {
                // --- ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÇ‡∏ã‡∏ô‡∏ï‡∏≤‡∏¢ (Deadzone) ‡πÉ‡∏´‡∏°‡πà ---
                const deadzoneTurn = 0.05;  // ‡πÄ‡∏•‡∏µ‡πâ‡∏¢‡∏ß: ‡πÑ‡∏ß‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏° (‡πÅ‡∏ï‡∏∞‡∏ô‡∏¥‡∏î‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡πÄ‡∏•‡∏µ‡πâ‡∏¢‡∏ß)
                
                const deadzoneAccel = 0.15; // ‡πÄ‡∏£‡πà‡∏á: ‡∏î‡∏±‡∏ô‡πÑ‡∏õ‡∏Ç‡πâ‡∏≤‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏ô‡∏¥‡∏î‡∏´‡∏ô‡πà‡∏≠‡∏¢‡∏Å‡πá‡∏ñ‡∏∑‡∏≠‡∏ß‡πà‡∏≤‡πÄ‡∏£‡πà‡∏á‡πÅ‡∏•‡πâ‡∏ß (‡∏ä‡πà‡∏ß‡∏¢‡∏ï‡∏≠‡∏ô‡πÄ‡∏•‡∏µ‡πâ‡∏¢‡∏ß‡∏™‡∏∏‡∏î‡πÅ‡∏•‡πâ‡∏ß‡∏Å‡πâ‡∏≤‡∏ô‡∏à‡∏≠‡∏¢‡∏ñ‡∏π‡∏Å‡∏ö‡∏µ‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡∏°‡∏≤)
                
                const deadzoneBrake = 0.60; // ‡πÄ‡∏ö‡∏£‡∏Å: **‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏°‡∏≤‡∏Å** ‡∏ï‡πâ‡∏≠‡∏á‡∏î‡∏∂‡∏á‡∏ñ‡∏≠‡∏¢‡∏´‡∏•‡∏±‡∏á‡πÄ‡∏Å‡∏¥‡∏ô 60% ‡∏ñ‡∏∂‡∏á‡∏à‡∏∞‡πÄ‡∏ö‡∏£‡∏Å (‡∏ñ‡πâ‡∏≤‡∏°‡∏∑‡∏≠‡πÄ‡∏ú‡∏•‡∏≠‡∏Å‡∏£‡∏∞‡∏ï‡∏∏‡∏Å‡∏ñ‡∏≠‡∏¢‡∏´‡∏•‡∏±‡∏á‡∏ô‡∏¥‡∏î‡∏´‡∏ô‡πà‡∏≠‡∏¢‡∏ï‡∏≠‡∏ô‡πÄ‡∏•‡∏µ‡πâ‡∏¢‡∏ß ‡∏à‡∏∞‡πÑ‡∏°‡πà‡πÄ‡∏ö‡∏£‡∏Å)

                // ‡πÅ‡∏Å‡∏ô X (‡πÄ‡∏•‡∏µ‡πâ‡∏¢‡∏ß‡∏ã‡πâ‡∏≤‡∏¢‡∏Ç‡∏ß‡∏≤ - Analog)
                if (Math.abs(gamepad.axes[0]) > deadzoneTurn) {
                    input.turnVal = gamepad.axes[0]; 
                }

                // ‡πÅ‡∏Å‡∏ô Y (‡πÄ‡∏£‡πà‡∏á/‡πÄ‡∏ö‡∏£‡∏Å)
                // Thrustmaster: ‡∏î‡∏±‡∏ô‡∏´‡∏ô‡πâ‡∏≤ = ‡∏Ñ‡πà‡∏≤‡∏ï‡∏¥‡∏î‡∏•‡∏ö (-), ‡∏î‡∏∂‡∏á‡∏´‡∏•‡∏±‡∏á = ‡∏Ñ‡πà‡∏≤‡∏ö‡∏ß‡∏Å (+)
                
                // ‡πÄ‡∏ä‡πá‡∏Ñ‡πÄ‡∏£‡πà‡∏á (Forward): ‡∏ñ‡πâ‡∏≤‡∏î‡∏±‡∏ô‡πÑ‡∏õ‡∏Ç‡πâ‡∏≤‡∏á‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏Å‡∏¥‡∏ô 15%
                if (gamepad.axes[1] < -deadzoneAccel) {
                    input.up = true;
                }
                
                // ‡πÄ‡∏ä‡πá‡∏Ñ‡πÄ‡∏ö‡∏£‡∏Å (Backward): ‡∏ñ‡πâ‡∏≤‡∏î‡∏∂‡∏á‡∏ñ‡∏≠‡∏¢‡∏´‡∏•‡∏±‡∏á‡πÄ‡∏Å‡∏¥‡∏ô 60% ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô
                if (gamepad.axes[1] > deadzoneBrake) {
                    input.down = true;
                }

                // ‡∏õ‡∏∏‡πà‡∏°‡∏¢‡∏¥‡∏á (Button 0 ‡∏´‡∏£‡∏∑‡∏≠ 1)
                if ((gamepad.buttons[0] && gamepad.buttons[0].pressed) || (gamepad.buttons[1] && gamepad.buttons[1].pressed)) input.fire = true;
            }
            return input;
        }

        function showSettings() { document.getElementById('settingsPanel').classList.remove('hidden'); gameRunning = false; }

        function startGame() {
            document.getElementById('settingsPanel').classList.add('hidden');
            // --- ‡πÇ‡∏Ñ‡πâ‡∏î‡πÉ‡∏´‡∏°‡πà: ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡πÑ‡∏ß ---
            const sensLevel = parseInt(document.getElementById('joySens').value);
            const sensMap = { 1: 0.03, 2: 0.05, 3: 0.07, 4: 0.10, 5: 0.14 }; // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏£‡∏∞‡∏î‡∏±‡∏ö
            playerTurnSpeed = sensMap[sensLevel]; 
            // ---------------------------
            const ballCount = parseInt(document.getElementById('redBallCount').value);
            const ballSpeedSetting = document.getElementById('redBallSpeed').value;
            const gameMinutes = parseInt(document.getElementById('gameTime').value);

            score = { points: 0, crashes: 0 };
            crashCooldown = 0;
            gameStartTime = Date.now();
            gameTimeLimit = gameMinutes * 60 * 1000;

            player.x = canvas.width / 2; player.y = canvas.height / 2; player.speed = 0; player.angle = Math.random() * Math.PI * 2;

            redBalls = [];
            targets = [{ color: 'green', colorHex: '#00ff88', x: 200, y: 200, radius: 20 }, { color: 'yellow', colorHex: '#ffff00', x: canvas.width - 200, y: 200, radius: 20 }];

            const speeds = { slow: 3.25, normal: 4.5, fast: 6.75, insane: 12.5 };
            const baseSpeed = speeds[ballSpeedSetting];

            for (let i = 0; i < ballCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                redBalls.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, vx: Math.cos(angle) * baseSpeed, vy: Math.sin(angle) * baseSpeed, radius: 22.5 });
            }

            generateTargetPositions();
            setNewTargetColor();
            gameRunning = true;
            gameLoop();
        }

        function generateTargetPositions() {
            targets.forEach(target => {
                const margin = target.radius + 50;
                target.x = margin + Math.random() * (canvas.width - margin * 2);
                target.y = margin + Math.random() * (canvas.height - margin * 2);
            });
        }
        function setNewTargetColor() {
            currentTargetColor = Math.random() < 0.5 ? 'green' : 'yellow';
            const targetDisplay = document.getElementById('target-display');
            const targetData = targets.find(t => t.color === currentTargetColor);
            if (targetDisplay && targetData) targetDisplay.style.backgroundColor = targetData.colorHex;
        }

        function update() {
            if (!gameRunning) return;
            updatePlayer();
            updateRedBalls();
            checkCollisions();
            updateUI();
        }

        function updatePlayer() {
            const input = getCombinedInput();

           // ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤ playerTurnSpeed ‡∏ó‡∏µ‡πà‡πÄ‡∏£‡∏≤‡∏ï‡∏±‡πâ‡∏á‡πÑ‡∏ß‡πâ‡∏ï‡∏≠‡∏ô startGame
            player.angle += input.turnVal * playerTurnSpeed;

            // ‡∏™‡πà‡∏ß‡∏ô‡πÄ‡∏£‡πà‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß/‡∏•‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°)
            if (input.up) player.speed = Math.min(player.speed + player.acceleration, player.maxSpeed);
            if (input.down) player.speed = Math.max(player.speed - player.acceleration * 2, 0);

            player.x += Math.cos(player.angle) * player.speed;
            player.y += Math.sin(player.angle) * player.speed;

            // ‡∏£‡∏∞‡∏ö‡∏ö‡∏ó‡∏∞‡∏•‡∏∏‡∏Ç‡∏≠‡∏ö‡∏à‡∏≠ (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°)
            if (player.x > canvas.width + player.radius) player.x = -player.radius;
            if (player.x < -player.radius) player.x = canvas.width + player.radius;
            if (player.y > canvas.height + player.radius) player.y = -player.radius;
            if (player.y < -player.radius) player.y = canvas.height + player.radius;

            // ‡∏£‡∏∞‡∏ö‡∏ö‡∏¢‡∏¥‡∏á (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°)
            if (input.fire && crashCooldown <= 0) {
                let targetHit = null;
                for (const target of targets) {
                    const dx = player.x - target.x;
                    const dy = player.y - target.y;
                    if (Math.sqrt(dx * dx + dy * dy) < target.radius) { targetHit = target; break; }
                }
                if (targetHit) {
                    if (targetHit.color === currentTargetColor) {
                        score.points++;
                        playSuccessSound(); generateTargetPositions(); setNewTargetColor();
                    } else {
                        score.crashes++;
                        playCrashSound(); crashCooldown = 60;
                    }
                }
            }
            if (crashCooldown > 0) crashCooldown--;
        }

        function updateRedBalls() {
            redBalls.forEach(ball => {
                ball.x += ball.vx; ball.y += ball.vy;
                if (ball.x <= ball.radius || ball.x >= canvas.width - ball.radius) { ball.vx *= -1; ball.x = Math.max(ball.radius, Math.min(canvas.width - ball.radius, ball.x)); }
                if (ball.y <= ball.radius || ball.y >= canvas.height - ball.radius) { ball.vy *= -1; ball.y = Math.max(ball.radius, Math.min(canvas.height - ball.radius, ball.y)); }
            });
        }
        function checkCollisions() {
            if (crashCooldown > 0) return;
            redBalls.forEach(ball => {
                if (Math.sqrt((player.x - ball.x) ** 2 + (player.y - ball.y) ** 2) < player.radius + ball.radius) {
                    score.crashes++; crashCooldown = 60; playCrashSound();
                    player.x = canvas.width / 2; player.y = canvas.height / 2; player.speed = 0;
                }
            });
        }
        function updateUI() {
            document.getElementById('points').textContent = score.points;
            document.getElementById('crashes').textContent = score.crashes;
            if (gameRunning) {
                const remaining = Math.max(0, gameTimeLimit - (Date.now() - gameStartTime));
                const minutes = Math.floor(remaining / 60000), seconds = Math.floor((remaining % 60000) / 1000);
                document.getElementById('timer').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                if (remaining <= 0) endGame();
            }
        }
        function endGame() {
            gameRunning = false;
            document.getElementById('finalPoints').textContent = score.points;
            document.getElementById('finalCrashes').textContent = score.crashes;
            document.getElementById('gameOverPanel').classList.remove('hidden');
        }

        function render() {
            ctx.fillStyle = '#000'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            stars.forEach(star => { ctx.beginPath(); ctx.fillStyle = `rgba(255, 255, 255, ${star.opacity})`; ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2); ctx.fill(); });
            targets.forEach(target => { ctx.beginPath(); ctx.fillStyle = target.colorHex; ctx.arc(target.x, target.y, target.radius, 0, Math.PI * 2); ctx.fill(); });
            redBalls.forEach(ball => { ctx.beginPath(); ctx.fillStyle = '#ff4444'; ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2); ctx.fill(); });
            ctx.save(); ctx.translate(player.x, player.y); ctx.rotate(player.angle);
            ctx.beginPath(); ctx.strokeStyle = crashCooldown > 0 ? '#ff4444' : '#00ccff'; ctx.lineWidth = 3; ctx.arc(0, 0, player.radius, 0, Math.PI * 2); ctx.stroke();
            ctx.restore();
        }
        function gameLoop() { if (gameRunning) { update(); render(); requestAnimationFrame(gameLoop); } }
        window.addEventListener('load', init);
        window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; });
    </script>
</body>

</html>









